Node.js 是一个基于事件的平台。这意味着 Node 中出现的东西都来源于事件。通过 Node 的事件遍历一系列的回调。

从开发人员处抽象出来，这一切都由叫 libuv 的库处理，它提供了一种称为事件循环的机制。

事件循环可能是 Node 中最被误解的概念。

我在 [Dynatrace](https://dynatrace.com) 工作，性能监测的供应商。当我们接到事件循环监测的主题时，我们很努力地去理解监测内容。

在这篇文章中，将介绍事件循环如何真正起作用以及如何正确监测它。

### 常见的误解

Libuv 是为 Node.js 提供事件循环的库。Bert Belder——Libuv 背后的关键人物，在 [Node Interactive 演讲中](https://www.youtube.com/watch?v=PNa9OMajw9w)，从展示 Google 图片搜索开始，该搜索展示了人们为了描绘事件循环而采取的各种不同方法，并且他的想法中大多数都是错误的。

![image](https://cdn-images-1.medium.com/max/1600/0*RdyghDfhxECLxI_Z.png)

我来谈谈最常见的误解。

### 误解1:事件循环运行在与用户代码分开的线程中

#### 误解

一个主线程用于运行用户的 JavaScript 代码（用户级代码），另一个用于运行事件循环。每次有异步操作时，主线程会把工作交给事件循环线程，完成后，事件循环线程会通知主线程执行回调。

#### 事实

Libuv 默认创造四个线程的线程池来卸载异步操作。现在的操作系统已经为很多 I/O 任务提供了异步接口(例如：Linux 中的 AIO)。Libuv 会尽可能使用异步接口，避免使用线程池。这同样适用于数据库等第三方子系统。比起线程池，驱动程序的作者更愿意使用异步接口。

简言之：只有在没有其他方式时，线程池才会被用于异步 I/O。

### 事件循环就像堆栈或队列

#### 误解

事件循环不断遍历异步任务的 FIFO，任务完成后执行回调。

#### 事实
虽然涉及到类似队列的结构，但事件循环不会贯穿并处理堆栈。事件循环作为一个过程是一组阶段，其中包含以循环方式处理的特定任务。

### 了解事件循环周期的阶段

要真正理解事件循环，必须了解在哪个阶段完成哪项工作。希望 Bert Belder 能够批准它，展示事件循环如何工作的方法如下：

![image](https://cdn-images-1.medium.com/max/1600/1*ROxiavz7LeRpIfcgRDE7CA.png)

<center>节点和事件循环周期</center>

一起讨论下这些阶段。更深入的解释可以去 [Node.js 网站](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)上了解。

### 计时器
通过 setTimeout() 或 setInterval() 计划的所有内容都将在这个阶段处理。

### IO 回调
大部分回调会在这个阶段被处理。由于 Node.js 中的所有用户级代码基本上都是回调（例如对传入 http 请求的回调触发级联回调），因此这是用户级代码。

### IO轮询

投票决定下一次执行的新事件。

### 立即设置

运行通过 setImmediate() 注册的所有回调。

### 关闭

这里处理 ('close') 事件回调。

### 监测事件循环
实际上，Node 应用程序中发生的所有事情都是通过事件循环运行的。这意味着我们可以从中得到指标。它应该给我们提供关于程序健壮性、性能有价值的信息。

没有 API 可以从事件循环中获取运行时指标，因此每个监控工具都提供了它们自己的指标。
来看看我们能得到什么。

### 节点频率

每个节点的次数。

### 节点时长

一个节点的时长。

由于我们的代理作为本地模块运行，因此添加探测器来为我们提供这些信息相对容易。

#### 节点频率和节点时长的指标

当我们在不同负载下进行第一次测试时，结果令人惊讶 —— 看下例子：

在下面的场景中，调用 express.js, 它可以访问一个外部的 http server。

有四种场景：

1.Idle

没有传入请求。

2.ab-c 5
 
用 apache 创建了5个并发请求。

3.ab-c 10

每次10个并发。

4.ab-c 10（后端较慢）

被调用的 http server 在1秒后返回数据以模拟慢速后端。这应该会导致所谓的反压，因为等待后端的请求在 Node 内返回堆积。

![image](https://cdn-images-1.medium.com/freeze/max/60/0*WqAUxk2NCgJkaRvp.png?q=20)

看图表结果，能得到一个有趣的现象：

事件循环持续时间和频率是动态调整的。

如果应用程序空闲，这意味着没有等待的任务（定时器、回调等）。全速运行是没有意义的，所以事件循环将适应并在轮询阶段阻塞一段时间，以等待新的外部事件进入。

这也意味着，空载状态下的指标类似于(低频率，高持续时间)与在高负载下与缓慢后端对话的应用程序。

我们还看到，此演示应用程序在5个同时请求的情况下运行“最佳”。

因此，在每秒的当前请求中，标记频率和标记持续时间需要基线分解。

虽然这些数据已经为我们提供了一些有价值的见解，但仍然不知道时间花在哪个阶段，因此我们进一步研究并提出了两个指标。

### 工作延迟处理

此指标测量线程池处理异步任务所需的时间。

处理高延迟的工作表明繁忙/耗尽的线程池。

为了测试这个指标，我创建了一个使用名为 [Sharp](https://www.npmjs.com/package/sharp) 的模块处理图像的快速路由。由于图像处理的成本很高，Shape 利用线程池来完成。

![image](https://cdn-images-1.medium.com/freeze/max/60/0*9WHmhn_8cLPyVOYb.png?q=20)

运行带有5个并发连接的 Apache 平台，对这条具有此图像处理功能的路径直接反映在该图表上，并且可以与没有适当位置图像处理的中等负载情况清楚地区分开来。

### Event Loop 延迟

事件循环延迟测量额外花费多长时间，直到用 setTimeout(X) 调度的任务真正得到处理。

高事件循环延迟表示事件循环处理回调繁忙。

为了测试这个指标，我创建了一个使用非常低效的算法计算斐波纳契的快速路线。

![image](https://cdn-images-1.medium.com/freeze/max/60/0*uqJLSsdlcDj9_IJL.png?q=20)

使用5个并发连接运行带有斐波那契函数的路由的 Apache 工作台显示现在回调队列正忙。

我们清楚地看到，这四个指标可以提供有价值的见解，并有助于更好地理解 Node.js 的内部工作。

所有这些都需要从更大的角度来看待，以便理解它。因此，我们正在收集信息，将这些数据纳入我们的异常检测。

### 调整事件循环

当然，如果不知道如何从可能的行为中解决问题，那么衡量标准本身就没有多大帮助。以下是当事件循环看起来被耗尽时该怎么做的一些提示。

![image](https://cdn-images-1.medium.com/freeze/max/60/0*FaJr2qBOxeCFaHaG.png?q=20)

### 利用所有的 CPU

Node.js 应用程序在单个线程上运行。
在多核机器上，意味着负载不分布在所有内核上。使用 Node 附带的 [cluster module](https://nodejs.org/api/cluster.html) 很容易为每个 CPU 产生一个子进程。每个子进程维护自己的事件循环，并且主进程透明地分配所有子进程之间的负载。

### 调整线程池

如前所述，libuv 将创建一个大小为4的线程池。通过设置环境变量 UV_THREADPOOL_SIZE 可以覆盖该池的默认大小。

虽然这可以解决 I/O 绑定应用程序中的加载问题，但我建议过度加载测试，因为较大的线程池可能会耗尽内存或 CPU。

### 将工作分配给服务

如果 Node.js 花费太多时间处理 CPU 繁重的操作，将工作卸载到服务甚至可能使用更适合特定任务的其他语言，这可能是一个可行的选择。

### 总结

总结一下我们在这篇文章中学到的东西：

- 事件循环是保持 Node.js 应用程序运行的
- 它的功能常常被误解—— 这是一组阶段，每个阶段都会连续执行特定的任务
- 事件循环没有提供现成的指标，因此收集的指标在 APM 供应商之间是不同的
- 这些指标显然提供了有关瓶颈的宝贵见解，但对事件循环的深入了解以及正在运行的代码是关键
- 未来，Dynatrace 会将事件循环遥测技术添加到其根本原因检测中，以将事件循环异常与问题相关联

对我来说，毫无疑问，我们今天刚刚在市场上建立了最全面的事件循环监控解决方案，我很高兴这个惊人的新功能将在未来几周内推出给所有客户。

### 功劳

Dynatrace 上 的Node.js 代理团队为获得事件循环监控权做了很多努力。本博文中的大部分发现都基于对 Node.js 内部工作原理的深入了解。我要感谢 Bernhard Liedl，Dominik Gruber，GerhardStöbich 和 Gernot Reisinger 的所有工作和支持。

我希望这篇文章能够阐明这个话题。
请在 twitter [@dkhan](https://twitter.com/dkhan) 上关注我。
我很高兴回答您的所有问题或下面的评论部分。

如果您仍然想了解更多关于事件循环的内部工作原理以及作为开发人员如何利用它们，[推荐这篇文章](https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/)。


如果您想尝试我们的 Node.js 监控，[请下载我们的免费试用版](https://www.dynatrace.com/technologies/nodejs-monitoring/)随时与我分享您的反馈——这是我们学习的方式。

 




